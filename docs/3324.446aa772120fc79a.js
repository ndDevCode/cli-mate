"use strict";(self.webpackChunkcli_mate=self.webpackChunkcli_mate||[]).push([[3324],{3324:(H,I,f)=>{f.r(I),f.d(I,{Particle:()=>Z});var w=f(1528),r=f(4784),p=f(1971),T=f(8252),O=f(5992),A=f(7200),k=f(5820),S=f(2816),B=f(6740),K=f(8040);const m=.5;function j(l){if(!(0,p.Sc)(l.outMode,l.checkModes))return;const o=2*l.radius;l.coord>l.maxCoord-o?l.setCb(-l.radius):l.coord<o&&l.setCb(l.radius)}class Z{constructor(o,n){this.container=n,this._calcPosition=(e,s,t,i=0)=>{for(const[,u]of e.plugins){const _=void 0!==u.particlePosition?u.particlePosition(s,this):void 0;if(_)return S.E.create(_.x,_.y,t)}const h=(0,r.ai)({size:e.canvas.size,position:s}),y=S.E.create(h.x,h.y,t),a=this.getRadius(),d=this.options.move.outModes,E=u=>{j({outMode:u,checkModes:["bounce"],coord:y.x,maxCoord:e.canvas.size.width,setCb:_=>y.x+=_,radius:a})},g=u=>{j({outMode:u,checkModes:["bounce"],coord:y.y,maxCoord:e.canvas.size.height,setCb:_=>y.y+=_,radius:a})};return E(d.left??d.default),E(d.right??d.default),g(d.top??d.default),g(d.bottom??d.default),this._checkOverlap(y,i)?this._calcPosition(e,void 0,t,i+1):y},this._calculateVelocity=()=>{const s=(0,r.hT)(this.direction).copy(),t=this.options.move;if("inside"===t.direction||"outside"===t.direction)return s;const i=(0,r.qy)((0,r.qS)(t.angle.value)),c=(0,r.qy)((0,r.qS)(t.angle.offset)),h={left:c-i*m,right:c+i*m};return t.straight||(s.angle+=(0,r.jy)((0,r.Ws)(h.left,h.right))),t.random&&"number"==typeof t.speed&&(s.length*=(0,r.CE)()),s},this._checkOverlap=(e,s=0)=>{const t=this.options.collisions,i=this.getRadius();if(!t.enable)return!1;const c=t.overlap;if(c.enable)return!1;const h=c.retries;if(h>=0&&s>h)throw new Error(`${T.iQ} particle is overlapping and can't be placed`);return!!this.container.particles.find(a=>(0,r.c$)(e,a.position)<i+a.getRadius())},this._getRollColor=e=>{if(!e||!this.roll||!this.backColor&&!this.roll.alter)return e;const c=this.roll.horizontal?Math.PI*m:0;return Math.floor(((this.roll.angle??0)+c)/(Math.PI/(this.roll.horizontal&&this.roll.vertical?2:1)))%2?this.backColor?this.backColor:this.roll.alter?(0,B.OY)(e,this.roll.alter.type,this.roll.alter.value):e:e},this._initPosition=e=>{const s=this.container,t=(0,r.qS)(this.options.zIndex.value);switch(this.position=this._calcPosition(s,e,(0,r.qk)(t,0,s.zLayers)),this.initialPosition=this.position.copy(),this.moveCenter={...(0,p.Gq)(this.options.move.center,s.canvas.size),radius:this.options.move.center.radius??0,mode:this.options.move.center.mode??"percent"},this.direction=(0,r.aC)(this.options.move.direction,this.position,this.moveCenter),this.options.move.direction){case"inside":this.outType="inside";break;case"outside":this.outType="outside"}this.offset=k.C.origin},this._engine=o}destroy(o){if(this.unbreakable||this.destroyed)return;this.destroyed=!0,this.bubble.inRange=!1,this.slow.inRange=!1;const n=this.container,e=this.pathGenerator;n.shapeDrawers.get(this.shape)?.particleDestroy?.(this);for(const[,t]of n.plugins)t.particleDestroyed?.(this,o);for(const t of n.particles.updaters)t.particleDestroyed?.(this,o);e?.reset(this),this._engine.dispatchEvent("particleDestroyed",{container:this.container,data:{particle:this}})}draw(o){var n=this;return(0,w.c)(function*(){const e=n.container,s=e.canvas;for(const[,t]of e.plugins)yield s.drawParticlePlugin(t,n,o);yield s.drawParticle(n,o)})()}getFillColor(){return this._getRollColor(this.bubble.color??(0,O._U)(this.color))}getMass(){return this.getRadius()**2*Math.PI*m}getPosition(){return{x:this.position.x+this.offset.x,y:this.position.y+this.offset.y,z:this.position.z}}getRadius(){return this.bubble.radius??this.size.value}getStrokeColor(){return this._getRollColor(this.bubble.color??(0,O._U)(this.strokeColor))}init(o,n,e,s){var t=this;return(0,w.c)(function*(){const i=t.container,c=t._engine;t.id=o,t.group=s,t.effectClose=!0,t.effectFill=!0,t.shapeClose=!0,t.shapeFill=!0,t.pathRotation=!1,t.lastPathTime=0,t.destroyed=!1,t.unbreakable=!1,t.rotation=0,t.misplaced=!1,t.retina={maxDistance:{}},t.outType="normal",t.ignoresResizeRatio=!0;const h=i.retina.pixelRatio,a=(0,K.o)(t._engine,i,i.actualOptions.particles),d=a.effect.type,E=a.shape.type,{reduceDuplicates:g}=a;t.effect=(0,p.pd)(d,t.id,g),t.shape=(0,p.pd)(E,t.id,g);const u=a.effect,_=a.shape;if(e){if(e.effect?.type){const P=(0,p.pd)(e.effect.type,t.id,g);P&&(t.effect=P,u.load(e.effect))}if(e.shape?.type){const P=(0,p.pd)(e.shape.type,t.id,g);P&&(t.shape=P,_.load(e.shape))}}t.effectData=function F(l,o,n,e){const s=o.options[l];if(s)return(0,p.Ww)({close:o.close,fill:o.fill},(0,p.pd)(s,n,e))}(t.effect,u,t.id,g),t.shapeData=function G(l,o,n,e){const s=o.options[l];if(s)return(0,p.Ww)({close:o.close,fill:o.fill},(0,p.pd)(s,n,e))}(t.shape,_,t.id,g),a.load(e);const b=t.effectData;b&&a.load(b.particles);const M=t.shapeData;M&&a.load(M.particles);const z=new A.O(c,i);z.load(i.actualOptions.interactivity),z.load(a.interactivity),t.interactivity=z,t.effectFill=b?.fill??a.effect.fill,t.effectClose=b?.close??a.effect.close,t.shapeFill=M?.fill??a.shape.fill,t.shapeClose=M?.close??a.shape.close,t.options=a;const R=t.options.move.path;t.pathDelay=(0,r.qS)(R.delay.value)*T.Ub,R.generator&&(t.pathGenerator=t._engine.getPathGenerator(R.generator),t.pathGenerator&&i.addPath(R.generator,t.pathGenerator)&&(yield t.pathGenerator.init(i))),i.retina.initParticle(t),t.size=(0,p.aI)(t.options.size,h),t.bubble={inRange:!1},t.slow={inRange:!1,factor:1},t._initPosition(n),t.initialVelocity=t._calculateVelocity(),t.velocity=t.initialVelocity.copy(),t.moveDecay=1-(0,r.qS)(t.options.move.decay);const x=i.particles;x.setLastZIndex(t.position.z),t.zIndexFactor=t.position.z/i.zLayers,t.sides=24;let C=i.effectDrawers.get(t.effect);C||(C=t._engine.getEffectDrawer(t.effect),C&&i.effectDrawers.set(t.effect,C)),C?.loadEffect&&(yield C.loadEffect(t));let D=i.shapeDrawers.get(t.shape);D||(D=t._engine.getShapeDrawer(t.shape),D&&i.shapeDrawers.set(t.shape,D)),D?.loadShape&&(yield D.loadShape(t));const L=D?.getSidesCount;L&&(t.sides=L(t)),t.spawning=!1,t.shadowColor=(0,O.WC)(t.options.shadow.color);for(const v of x.updaters)yield v.init(t);for(const v of x.movers)yield v.init?.(t);yield C?.particleInit?.(i,t),yield D?.particleInit?.(i,t);for(const[,v]of i.plugins)v.particleCreated?.(t)})()}isInsideCanvas(){const o=this.getRadius(),n=this.container.canvas.size,e=this.position;return e.x>=-o&&e.y>=-o&&e.y<=n.height+o&&e.x<=n.width+o}isVisible(){return!this.destroyed&&!this.spawning&&this.isInsideCanvas()}reset(){for(const o of this.container.particles.updaters)o.reset?.(this)}}}}]);